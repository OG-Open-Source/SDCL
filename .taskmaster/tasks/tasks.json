{
  "tasks": [
    {
      "id": 1,
      "title": "Setup Go Module",
      "description": "Initialize the Go module for the project with the specified module path.",
      "details": "",
      "testStrategy": "Verify that go.mod file is created with the correct module path and Go version 1.23 specified. Run `go mod tidy` to ensure no immediate errors.",
      "priority": "medium",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 2,
      "title": "Define Token Types",
      "description": "Define Go structs or enums to represent all distinct token types identified by the lexer.",
      "details": "",
      "testStrategy": "Review the Go code to ensure all specified token types (STRING, INTEGER, FLOAT, BOOLEAN, NULL, DATE, TIME, DATETIME, COUNTRY, BASE64, KEY, COLON, LBRACE, RBRACE, LBRACKET, RBRACKET, LPAREN, RPAREN, DOUBLE_LPAREN, DOUBLE_RPAREN, DOT, HASH, FRONTMATTER_DELIMITER, WHITESPACE, NEWLINE, EOF, ILLEGAL) are defined, likely as an iota-based enum.",
      "priority": "medium",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "Define AST Node Structures",
      "description": "Define Go interfaces and structs to represent the nodes of the Abstract Syntax Tree (AST) for the SDCL structure.",
      "details": "",
      "testStrategy": "Review the Go code to ensure interfaces (e.g., `Node`, `Expression`, `Statement`) and concrete structs (e.g., `Document`, `ObjectLiteral`, `ArrayLiteral`, `KeyValuePair`, `StringLiteral`, `ValueReference`) are defined to cover all SDCL constructs.",
      "priority": "medium",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "Implement Lexer Core",
      "description": "Implement the core logic of the lexer (tokenizer) to read input character by character and identify the start of potential tokens.",
      "details": "",
      "testStrategy": "Create basic test cases with simple inputs (e.g., `key: \"value\"`) and verify that the lexer can read characters and identify basic token boundaries. Use Go's `testing` package. Consider using `bufio.Reader` for efficient character reading.",
      "priority": "medium",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "Lexer: Handle Whitespace and Newlines",
      "description": "Enhance the lexer to correctly handle single and multiple spaces and newlines, distinguishing between significant delimiters and ignorable whitespace.",
      "details": "",
      "testStrategy": "Write unit tests for the lexer with various combinations of spaces and newlines (e.g., `key : value`, `key:\nvalue`, `key:  \n  value`). Verify that whitespace is correctly skipped or tokenized as required by the spec.",
      "priority": "medium",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 6,
      "title": "Lexer: Handle Comments",
      "description": "Add logic to the lexer to identify lines starting with '#' as comments and emit a COMMENT token.",
      "details": "",
      "testStrategy": "Write unit tests for the lexer including lines starting with '#'. Verify that the lexer correctly identifies the '#' and tokenizes the rest of the line as a COMMENT.",
      "priority": "medium",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 7,
      "title": "Lexer: Handle Front Matter Delimiter",
      "description": "Implement recognition of the '---' sequence on a new line as a FRONTMATTER_DELIMITER token in the lexer.",
      "details": "",
      "testStrategy": "Write unit tests for the lexer with '---' on a new line. Verify that the lexer correctly identifies and emits the FRONTMATTER_DELIMITER token.",
      "priority": "medium",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 8,
      "title": "Lexer: Ensure UTF-8 Support",
      "description": "Ensure the lexer correctly handles multi-byte UTF-8 characters in strings and keys using Go's `rune` type.",
      "details": "",
      "testStrategy": "Write unit tests for the lexer with SDCL content containing non-ASCII UTF-8 characters in strings and keys (e.g., `ключ: \"значение\"`, `你好: \"世界\"`). Verify that the lexer correctly reads and tokenizes these characters.",
      "priority": "medium",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 9,
      "title": "Implement Parser Core",
      "description": "Implement the core structure of the recursive descent parser, consuming tokens from the lexer and initiating the AST building process.",
      "details": "",
      "testStrategy": "Create a basic parser structure that can consume tokens from a mock lexer. Implement basic token matching and error handling for unexpected tokens. Use Go's `testing` package.",
      "priority": "medium",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 10,
      "title": "Parser: Top-Level Document Parsing",
      "description": "Implement the parser logic to handle the top-level structure of an SDCL document, which consists of a sequence of key-value pairs, comments, and inclusions.",
      "details": "",
      "testStrategy": "Write unit tests with simple top-level key-value pairs and comments (e.g., `key1: value1\nkey2: value2\n# comment`). Verify that the parser correctly builds the top-level AST nodes.",
      "priority": "medium",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 11,
      "title": "Parser: Object Parsing and Dot-Notation Keys",
      "description": "Implement the parser logic to handle object structures defined within curly braces `{}` and correctly parse nested objects based on dot-notation keys (`a.b.c: value`).",
      "details": "",
      "testStrategy": "Write unit tests for object parsing (e.g., `{ key: value }`, `{ a.b: value }`, `{ a: { b: value } }`). Verify that the parser correctly builds nested AST structures for dot-notation keys and standard objects.",
      "priority": "medium",
      "dependencies": [],
      "status": "in-progress",
      "subtasks": []
    },
    {
      "id": 12,
      "title": "Parser: Array Parsing",
      "description": "Implement the parser logic to handle array structures defined within square brackets `[]` and parse sequences of values.",
      "details": "",
      "testStrategy": "Write unit tests for array parsing (e.g., `[ value1 value2 ]`, `[ 1 \"string\" true ]`). Verify that the parser correctly builds array AST nodes.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 13,
      "title": "Parser: Enforce No Commas",
      "description": "Modify the parser to detect and report an error if a comma (`,`) is found within an object or array.",
      "details": "",
      "testStrategy": "Write unit tests with invalid SDCL containing commas (e.g., `{ key1: value1, key2: value2 }`, `[ value1, value2 ]`). Verify that the parser correctly identifies the comma and returns a syntax error.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 14,
      "title": "Parser: Enforce Double-Quoted Strings",
      "description": "Modify the parser to enforce that all literal strings are enclosed in double quotes (`\"`).",
      "details": "",
      "testStrategy": "Write unit tests with invalid SDCL containing single-quoted or unquoted strings (e.g., `key: 'value'`, `key: value`). Verify that the parser correctly identifies these as syntax errors.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 15,
      "title": "Parser: Enforce Key Naming Rules",
      "description": "Modify the parser to enforce that key names do not contain spaces or dots, except when used for nested structure definition via dot-notation.",
      "details": "",
      "testStrategy": "Write unit tests with invalid key names (e.g., `my key: value`, `my.key.name: value` where `my.key.name` is intended as a single key, not nested). Verify that the parser correctly identifies and reports these syntax errors.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 16,
      "title": "Parser: Detect Duplicate Keys",
      "description": "Implement logic in the parser to detect and report an error if duplicate keys are defined directly within the same object scope.",
      "details": "",
      "testStrategy": "Write unit tests with objects containing duplicate keys at the same level (e.g., `{ key: value1\nkey: value2 }`). Verify that the parser correctly detects the duplicate and returns a syntax error.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 17,
      "title": "Parser: Enforce Form Consistency",
      "description": "Implement logic in the parser to detect if a document mixes Expanded and Compact forms and report an error if it does.",
      "details": "",
      "testStrategy": "Write unit tests with SDCL content that mixes forms (e.g., top-level key-value pairs followed by a root object `{...}`). Verify that the parser correctly identifies the mixed form and returns a syntax error.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 18,
      "title": "Implement Semantic Analyzer Core",
      "description": "Create the core structure for the semantic analyzer/resolver component that traverses the parsed AST.",
      "details": "",
      "testStrategy": "Create a basic AST traversal mechanism. Write tests to ensure the analyzer can visit different node types in a simple AST. This component will likely hold the state of the resolved data structure.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 19,
      "title": "Resolver: Value Reference Resolution",
      "description": "Implement the logic within the semantic analyzer to resolve value references `(path.to.value)` by traversing the AST and linking to the target value.",
      "details": "",
      "testStrategy": "Write unit tests with SDCL containing value references (e.g., `value1: 10\nvalue2: (value1)`). Verify that the resolver correctly finds the target value and represents the reference in the resolved data structure.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 20,
      "title": "Resolver: Content Inclusion Resolution (Merge)",
      "description": "Implement the logic to resolve content inclusion references `(path.to.structure)` by merging the content of the referenced object or array into the current scope.",
      "details": "",
      "testStrategy": "Write unit tests with SDCL containing merge inclusions (e.g., `obj1: { a: 1 }\nobj2: (obj1)`). Verify that the resolver correctly merges the content of `obj1` into `obj2`.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 21,
      "title": "Resolver: Content Inclusion Resolution (Embed)",
      "description": "Implement the logic to resolve content inclusion references `((path.to.structure))` by embedding the entire referenced structure (including its key) into the current scope.",
      "details": "",
      "testStrategy": "Write unit tests with SDCL containing embed inclusions (e.g., `obj1: { a: 1 }\nobj2: ((obj1))`). Verify that the resolver correctly embeds `obj1` as a nested structure within `obj2`.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 22,
      "title": "Resolver: Implement 'Last Definition Wins'",
      "description": "Implement the 'last definition wins' rule for merging/overriding keys during content inclusion resolution.",
      "details": "",
      "testStrategy": "Write unit tests with SDCL where a key is defined in both the source and target of a merge inclusion (e.g., `obj1: { a: 1, b: 2 }\nobj2: { b: 3, c: 4 }\nfinal: (obj1) (obj2)`). Verify that the key from the later inclusion (`obj2.b`) overrides the earlier one (`obj1.b`).",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 23,
      "title": "Resolver: External .env Reference Resolution",
      "description": "Implement the resolution of `.env.VAR` references by reading environment variables from the process.",
      "details": "",
      "testStrategy": "Write unit tests that set environment variables before parsing SDCL containing `.env.VAR` references (e.g., `config: { user: (.env.USER) }`). Verify that the resolver correctly fetches the environment variable value.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 24,
      "title": "Resolver: External .sdcl Reference Resolution",
      "description": "Implement the resolution of `.file.sdcl.path` references, including setting up a file loader with a configurable search path strategy.",
      "details": "",
      "testStrategy": "Create mock `.sdcl` files and write unit tests that parse a main file referencing them (e.g., `include: (.file.sdcl.other.sdcl)`). Configure search paths and verify that the resolver can find and parse the external file and include its content.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 25,
      "title": "Resolver: Circular Reference Detection",
      "description": "Implement algorithms to detect and report errors for circular dependencies involving value references, content inclusions, and external `.sdcl` references.",
      "details": "",
      "testStrategy": "Write unit tests with SDCL containing circular references (e.g., `a: (b)\nb: (a)`, `obj1: (obj2)\nobj2: (obj1)`, file A includes file B, file B includes file A). Verify that the resolver detects the cycle and returns an appropriate error.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 26,
      "title": "Semantic: Explicit Type Tag Validation",
      "description": "During semantic analysis, validate that values associated with explicit type tags (`<type>`) conform to the specified format for that type.",
      "details": "",
      "testStrategy": "Write unit tests with values tagged with types (e.g., `date: <DATE>\"2023-10-27\"`, `date: <DATE>\"invalid-date\"`). Verify that the validator accepts valid formats and rejects invalid ones, reporting errors.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 27,
      "title": "Data Conversion to Standard Go Types",
      "description": "Implement the final conversion of the internal resolved data structure (likely the result of the semantic analysis) into standard Go types (`map[string]interface{}` and `[]interface{}`).",
      "details": "",
      "testStrategy": "After resolving a sample AST, convert it to `map[string]interface{}`. Write tests to verify that the structure and data types in the resulting Go map/slice match the expected output based on the resolved SDCL.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 28,
      "title": "Implement Public API",
      "description": "Design and implement the main public API functions, `Parse([]byte)` and `ParseFile(string)`, which orchestrate the lexing, parsing, and semantic analysis steps.",
      "details": "",
      "testStrategy": "Write integration tests using the public `Parse` and `ParseFile` functions with simple valid SDCL inputs. Verify that they return the expected `map[string]interface{}` and no error.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 29,
      "title": "Implement Comprehensive Error Reporting",
      "description": "Ensure that errors from the lexer, parser, semantic analyzer, and resolver are caught and propagated through the public API with clear messages, including line and column numbers where applicable.",
      "details": "",
      "testStrategy": "Write integration tests using the public API with various invalid SDCL inputs (syntax errors, semantic errors, circular references, invalid types). Verify that the correct error type is returned, the message is informative, and line/column information is present.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 30,
      "title": "Develop CLI Tool",
      "description": "Develop a simple command-line interface tool using the public API to parse a given SDCL file and print the result or error.",
      "details": "",
      "testStrategy": "Build the CLI tool. Test it from the command line with valid and invalid `.sdcl` files. Verify that it prints a success message or the formatted error output as expected.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 31,
      "title": "Write Unit Tests",
      "description": "Write comprehensive unit tests for the lexer, parser, and resolver components, covering all rules, data types, and edge cases defined in the specification.",
      "details": "",
      "testStrategy": "Ensure high test coverage (aim for >90%) for the core lexing, parsing, and resolving logic. Use Go's `testing` package and potentially table-driven tests for different inputs/outputs.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 32,
      "title": "Write Integration Tests",
      "description": "Create a suite of `.sdcl` test files (valid and invalid) and write integration tests that use the public API to parse these files, asserting the correctness of the output or the error messages.",
      "details": "",
      "testStrategy": "Create a directory of test `.sdcl` files. Write Go tests that iterate through these files, call `ParseFile`, and compare the output (or error) against expected results stored in corresponding `.json` or `.err` files.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 33,
      "title": "Write API Documentation (godoc)",
      "description": "Add clear and comprehensive `godoc` comments to all public functions, types, and constants in the library.",
      "details": "",
      "testStrategy": "Run `godoc` or `go doc` locally and review the generated documentation for clarity, completeness, and correctness. Ensure all public elements are documented.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 34,
      "title": "Write README Documentation",
      "description": "Create a comprehensive `README.md` file explaining the project, how to install and use the library, providing code examples, and outlining the CLI usage.",
      "details": "",
      "testStrategy": "Review the `README.md` file for clarity, accuracy, and completeness. Ensure it covers installation, library usage examples, CLI usage, and links to the SDCL specification.",
      "priority": "medium",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    }
  ]
}