# Product Requirements Document (PRD) for SDCL Golang Interpreter (Detailed)

## 1. Project Goal
Develop a high-performance, fully compliant, and robust interpreter for the SDCL (OGATA's Standard Data Character Storage Language) specification using Golang version 1.23. This project will serve as the official reference implementation and a production-ready library. The implementation must be based on the comprehensive rules defined in the multi-language specification documents (`sdcl_en.md`, `sdcl_zh_hant.md`, `sdcl_zh_hans.md`).

The Go module name for this project is `github.com/OG-Open-Source/SDCL`.

## 2. Core Epics and Feature Breakdown

### Epic 1: Lexical Analysis (Lexer/Tokenizer)

**User Story:** As a developer, I want the interpreter to accurately scan SDCL source text and convert it into a stream of tokens, so that the parser can process it.

**Tasks:**
1.  **Token Definition:** Define Go structs/enums for all SDCL tokens, including: `STRING`, `INTEGER`, `FLOAT`, `BOOLEAN`, `NULL`, `DATE`, `TIME`, `DATETIME`, `COUNTRY`, `BASE64`, `KEY`, `COLON`, `LBRACE`, `RBRACE`, `LBRACKET`, `RBRACKET`, `LPAREN`, `RPAREN`, `DOUBLE_LPAREN`, `DOUBLE_RPAREN`, `DOT`, `HASH`, `FRONTMATTER_DELIMITER`, `WHITESPACE`, `NEWLINE`, `EOF`, and `ILLEGAL`.
2.  **Lexer Implementation:** Create a stateful lexer that reads the input character by character and emits the correct tokens.
3.  **Whitespace and Newline Handling:** The lexer must correctly handle single or multiple spaces and newlines as significant delimiters or ignorable whitespace depending on the context.
4.  **Comment Handling:** The lexer must identify hash (`#`) symbols and treat the rest of the line as a `COMMENT` token, which the parser will later discard.
5.  **Front Matter Delimiter:** The lexer must recognize `---` on a new line as a `FRONTMATTER_DELIMITER` token.
6.  **UTF-8 Support:** Ensure the lexer is fully UTF-8 compliant for string content and keys.

### Epic 2: Syntactic Analysis (Parser)

**User Story:** As a developer, I want the interpreter to parse the token stream into a structured Abstract Syntax Tree (AST) that represents the SDCL document's hierarchy and relationships.

**Tasks:**
1.  **AST Node Definition:** Define Go interfaces and structs for all AST nodes, such as `Document`, `Object`, `Array`, `KeyValue`, `StringLiteral`, `IntegerLiteral`, `FloatLiteral`, `BooleanLiteral`, `NullLiteral`, `DateLiteral`, `TimeLiteral`, `DateTimeLiteral`, `CountryLiteral`, `Base64Literal`, `ValueReference`, `ContentInclusion`, `ExternalReference`, etc.
2.  **Parser Implementation:** Implement a recursive descent parser that consumes tokens from the lexer and builds the AST.
3.  **Top-Level Parsing:** Parse a sequence of key-value pairs, comments, and inclusions that constitute the document body.
4.  **Object Parsing:** Parse key-value pairs within curly braces `{}`. Handle dot-notation keys (`a.b.c: value`) by creating nested object structures within the AST.
5.  **Array Parsing:** Parse a sequence of values within square brackets `[]`.
6.  **Strict Syntax Enforcement:**
    *   **No Commas:** The parser must throw an error if a comma is found separating elements in an array or object.
    *   **String Quotes:** Enforce that all literal strings are double-quoted.
    *   **Key Naming:** Enforce that key names do not contain spaces or dots.
    *   **Duplicate Keys:** Detect and throw an error for directly defined duplicate keys within the same object scope.
    *   **Form Consistency:** Implement logic to detect and enforce that a document uses either Expanded or Compact form, but not a mix.

### Epic 3: Semantic Analysis and Feature Implementation

**User Story:** As a developer, I want the interpreter to correctly resolve all references, inclusions, and other dynamic features of SDCL to produce the final, fully-resolved data structure.

**Tasks:**
1.  **Semantic Analyzer/Resolver:** Create a new component that walks the AST after parsing is complete.
2.  **Value Reference (`(...)`) Resolution:** Implement logic to traverse the AST and resolve `(path.to.value)` references. The resolver must store the final data in a structure that reflects the "live link" nature of the reference.
3.  **Content Inclusion (`(...)` and `((...))`) Resolution:**
    *   Implement logic to resolve `(path.to.structure)` by merging the content of the referenced object/array into the target scope.
    *   Implement logic to resolve `((path.to.structure))` by embedding the entire referenced structure (including its key) into the target scope.
    *   Implement the "last definition wins" rule for merging/overriding keys.
4.  **External Reference (`.env` and `.sdcl`) Resolution:**
    *   Implement `.env.VAR` resolution by reading from the process environment variables.
    *   Implement `.file.sdcl.path` resolution. This requires a file loader with a configurable search path strategy (relative path, predefined search directories).
5.  **Circular Reference Detection:** Implement algorithms to detect and throw errors for circular dependencies across all reference and inclusion types (internal and external).
6.  **Explicit Type Tag (`<type>`) Validation:** During semantic analysis, if a type tag is present, validate that the associated value conforms to the tag's specified format.

### Epic 4: Public API and CLI

**User Story:** As a user of the library, I want a simple and intuitive API to parse SDCL content, and a CLI tool to quickly validate files.

**Tasks:**
1.  **Public API Design:** Design the primary public functions: `Parse(input []byte) (map[string]interface{}, error)` and `ParseFile(filepath string) (map[string]interface{}, error)`.
2.  **Data Conversion:** Implement the final conversion from the internal resolved AST/data structure into standard Go types (`map[string]interface{}` and `[]interface{}`).
3.  **Error Reporting:** Ensure all errors (lexical, syntactic, semantic) are propagated to the public API with clear, user-friendly messages, including line and column numbers where possible.
4.  **CLI Tool Development:** Create a `main` package for a simple CLI tool that takes a file path, uses the library to parse it, and prints either a success message or the formatted error.
5.  **Go Module Setup:** Initialize `go.mod` with the module path `github.com/OG-Open-Source/SDCL` and manage dependencies.

### Epic 5: Testing and Documentation

**User Story:** As a maintainer and user, I want to be confident in the interpreter's correctness and know how to use it.

**Tasks:**
1.  **Unit Testing:** Write extensive unit tests for the lexer, parser, and resolver components, covering every data type, syntax rule, and edge case.
2.  **Integration Testing:** Create a suite of `.sdcl` test files containing valid and invalid syntax, and write integration tests that parse these files and assert the correctness of the output or the error messages.
3.  **API Documentation:** Write clear `godoc` comments for all public functions, types, and constants.
4.  **README Documentation:** Create a comprehensive `README.md` file explaining the project, how to install and use the library, and providing examples.

## 3. Non-Functional Requirements
- **Performance:** The interpreter should be designed for high performance, minimizing memory allocations and processing time.
- **Concurrency:** The public API should be safe for concurrent use.
- **Compliance:** The interpreter must strictly adhere to all rules laid out in the SDCL specification documents.